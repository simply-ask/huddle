{% extends 'base.html' %}
{% load static %}

{% block title %}Meeting: {{ meeting.title|default:meeting.meeting_id }}{% endblock %}

{% block extra_css %}
<style>
    /* Meeting room styles - clean Toaster UI */
    .meeting-container {
        max-width: 1200px;
        margin: 0 auto;
        padding-bottom: 100px; /* Space for fixed controls */
    }
    
    /* Header section */
    .meeting-header {
        margin-bottom: 32px;
    }
    
    .meeting-title {
        font-size: 28px;
        font-weight: 300;
        margin-bottom: 8px;
    }
    
    /* Recording indicator */
    .recording-indicator {
        position: fixed;
        top: 20px;
        right: 20px;
        background: #dc3545;
        color: white;
        padding: 12px 20px;
        border-radius: 24px;
        display: none;
        align-items: center;
        gap: 10px;
        z-index: 1000;
        animation: fadeIn 0.3s ease;
    }
    
    .recording-indicator.active {
        display: flex;
    }
    
    .recording-dot {
        width: 10px;
        height: 10px;
        background: white;
        border-radius: 50%;
        animation: pulse 1.5s infinite;
    }
    
    @keyframes pulse {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.3; }
    }
    
    @keyframes fadeIn {
        from { opacity: 0; transform: translateY(-10px); }
        to { opacity: 1; transform: translateY(0); }
    }
    
    /* Participants section */
    .participants-card {
        background: rgba(255, 255, 255, 0.05);
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 8px;
        padding: 24px;
        margin-bottom: 24px;
        backdrop-filter: blur(10px);
    }
    
    .host-info {
        display: flex;
        align-items: center;
        gap: 16px;
    }
    
    .host-icon {
        width: 48px;
        height: 48px;
        background: rgba(100, 169, 63, 0.2);
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 24px;
    }
    
    .host-badge {
        background: #64a93f;
        color: white;
        padding: 4px 12px;
        border-radius: 20px;
        font-size: 11px;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.5px;
    }
    
    /* Speaker management */
    .speaker-management {
        background: rgba(255, 255, 255, 0.05);
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 8px;
        padding: 24px;
        margin-bottom: 24px;
        display: none;
    }
    
    .speaker-management.visible {
        display: block;
        animation: fadeIn 0.3s ease;
    }
    
    .speaker-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
        gap: 12px;
        margin: 20px 0;
    }
    
    .speaker-card {
        background: rgba(255, 255, 255, 0.08);
        border: 1px solid rgba(255, 255, 255, 0.15);
        border-radius: 6px;
        padding: 12px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        transition: all 0.2s;
    }
    
    .speaker-card:hover {
        background: rgba(255, 255, 255, 0.12);
        transform: translateY(-1px);
    }
    
    .speaker-card.verified {
        border-color: #64a93f;
        background: rgba(100, 169, 63, 0.1);
    }
    
    .speaker-card.unknown {
        border-color: #ffc107;
        background: rgba(255, 193, 7, 0.1);
    }
    
    .speaker-info {
        display: flex;
        align-items: center;
        gap: 8px;
    }
    
    .speaker-confidence {
        font-size: 12px;
        color: rgba(255, 255, 255, 0.6);
    }
    
    .edit-speaker-btn {
        background: transparent;
        border: none;
        color: rgba(255, 255, 255, 0.7);
        cursor: pointer;
        padding: 4px;
        transition: color 0.2s;
    }
    
    .edit-speaker-btn:hover {
        color: #fff;
    }
    
    /* Transcript section */
    .transcript-container {
        background: rgba(255, 255, 255, 0.05);
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 8px;
        padding: 24px;
        margin-bottom: 24px;
        max-height: 400px;
        overflow-y: auto;
    }
    
    .transcript-container::-webkit-scrollbar {
        width: 8px;
    }
    
    .transcript-container::-webkit-scrollbar-track {
        background: rgba(255, 255, 255, 0.05);
        border-radius: 4px;
    }
    
    .transcript-container::-webkit-scrollbar-thumb {
        background: rgba(255, 255, 255, 0.2);
        border-radius: 4px;
    }
    
    .transcript-container::-webkit-scrollbar-thumb:hover {
        background: rgba(255, 255, 255, 0.3);
    }
    
    .transcript-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 20px;
    }
    
    .transcript-title {
        font-size: 18px;
        font-weight: 500;
    }
    
    .transcript-status {
        font-size: 12px;
        color: rgba(255, 255, 255, 0.6);
    }
    
    .transcript-segment {
        margin: 16px 0;
        padding: 16px;
        background: rgba(255, 255, 255, 0.03);
        border-left: 3px solid rgba(255, 255, 255, 0.1);
        border-radius: 4px;
        transition: all 0.2s;
    }
    
    .transcript-segment:hover {
        background: rgba(255, 255, 255, 0.05);
        border-left-color: #64a93f;
    }
    
    .speaker-label {
        font-weight: 500;
        margin-bottom: 8px;
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 14px;
    }
    
    .speaker-label.unknown {
        color: #ffc107;
    }
    
    .transcript-text {
        color: rgba(255, 255, 255, 0.9);
        line-height: 1.6;
    }
    
    .speaker-dropdown {
        background: rgba(255, 255, 255, 0.9);
        color: #0a2134;
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 4px;
        padding: 4px 8px;
        font-size: 13px;
        margin-left: 8px;
    }
    
    /* Fixed controls bar */
    .controls-bar {
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        background: rgba(10, 33, 52, 0.95);
        backdrop-filter: blur(20px);
        border-top: 1px solid rgba(255, 255, 255, 0.1);
        padding: 20px;
        z-index: 999;
    }
    
    .controls-container {
        max-width: 1200px;
        margin: 0 auto;
        display: flex;
        justify-content: center;
        align-items: center;
        gap: 16px;
    }
    
    .control-btn {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        padding: 12px 24px;
        border: none;
        border-radius: 8px;
        font-size: 15px;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s;
        color: white;
    }
    
    .control-btn-record {
        background: #dc3545;
    }
    
    .control-btn-record:hover {
        background: #c82333;
        transform: translateY(-1px);
    }
    
    .control-btn-stop {
        background: #64a93f;
    }
    
    .control-btn-stop:hover {
        background: #548832;
        transform: translateY(-1px);
    }
    
    .control-btn-leave {
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
    }
    
    .control-btn-leave:hover {
        background: rgba(255, 255, 255, 0.2);
    }
    
    .control-btn-end {
        background: rgba(220, 53, 69, 0.2);
        border: 1px solid #dc3545;
        color: #ff6b6b;
    }
    
    .control-btn-end:hover {
        background: rgba(220, 53, 69, 0.3);
    }
    
    /* Empty state */
    .empty-state {
        text-align: center;
        padding: 40px;
        color: rgba(255, 255, 255, 0.5);
    }
    
    .empty-state i {
        font-size: 48px;
        margin-bottom: 16px;
        opacity: 0.5;
    }
    
    /* Role badge */
    .role-badge {
        position: absolute;
        top: 20px;
        left: 20px;
        padding: 8px 16px;
        border-radius: 20px;
        font-size: 12px;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.5px;
    }
    
    .role-badge.host {
        background: #64a93f;
        color: white;
    }
    
    .role-badge.participant {
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
        color: rgba(255, 255, 255, 0.8);
    }
    
    /* Responsive */
    @media (max-width: 768px) {
        .meeting-container {
            padding-bottom: 120px;
        }
        
        .controls-container {
            flex-wrap: wrap;
        }
        
        .speaker-grid {
            grid-template-columns: 1fr;
        }
    }
</style>
{% endblock %}

{% block content %}
<div class="meeting-container">
    <!-- Role indicator -->
    <div class="role-badge {{ user.id == meeting.host.id|yesno:'host,participant' }}" id="roleBadge">
        <i class="fas fa-{{ user.id == meeting.host.id|yesno:'crown,eye' }}"></i>
        {{ user.id == meeting.host.id|yesno:'Host,Viewer' }}
    </div>
    
    <!-- Recording indicator -->
    <div class="recording-indicator" id="recordingIndicator">
        <div class="recording-dot"></div>
        <span>Recording</span>
    </div>
    
    <!-- Meeting header -->
    <div class="meeting-header">
        <h1 class="meeting-title">{{ meeting.title|default:"Meeting" }}</h1>
        <div class="text-muted">
            <i class="fas fa-hashtag"></i>
            Meeting ID: {{ meeting.meeting_id }}
        </div>
    </div>
    
    <!-- Participants section -->
    <div class="participants-card">
        <div class="flex-between">
            <div class="host-info">
                <div class="host-icon">
                    <i class="fas fa-phone"></i>
                </div>
                <div>
                    <div class="flex gap-10">
                        <strong>{{ meeting.host.get_full_name|default:meeting.host.username }}</strong>
                        <span class="host-badge">Host</span>
                    </div>
                    <div class="text-small text-muted">Recording Device</div>
                </div>
            </div>
            <div class="text-muted">
                <i class="fas fa-users"></i>
                <span id="participantCount">0</span> viewing
            </div>
        </div>
    </div>
    
    <!-- Speaker management (host only) -->
    <div class="speaker-management" id="speakerManagement">
        <div class="flex-between mb-20">
            <div>
                <h3 style="font-size: 18px; font-weight: 500; margin-bottom: 4px;">
                    <i class="fas fa-users"></i> Active Speakers
                </h3>
                <div class="text-small text-muted">Manage speaker identification</div>
            </div>
            <div class="flex gap-10">
                <button class="btn btn-small btn-secondary" id="addSpeakerBtn">
                    <i class="fas fa-plus"></i>
                    Add
                </button>
                <button class="btn btn-small btn-secondary" id="refreshSpeakersBtn">
                    <i class="fas fa-sync"></i>
                    Refresh
                </button>
            </div>
        </div>
        
        <div class="speaker-grid" id="activeSpeakers">
            <!-- Speaker cards will be populated dynamically -->
        </div>
    </div>
    
    <!-- Transcript section -->
    <div class="transcript-container">
        <div class="transcript-header">
            <h3 class="transcript-title">
                <i class="fas fa-closed-captioning"></i>
                Live Transcript
            </h3>
            <div class="transcript-status" id="transcriptStatus">
                Waiting to start...
            </div>
        </div>
        
        <div id="transcriptContent">
            <div class="empty-state">
                <i class="fas fa-microphone-slash"></i>
                <p>Transcript will appear here when recording starts</p>
            </div>
        </div>
    </div>
</div>

<!-- Fixed controls bar -->
<div class="controls-bar">
    <div class="controls-container" id="controlsContainer">
        <!-- Controls will be added dynamically based on user role -->
    </div>
</div>

<script>
    const meetingId = "{{ meeting.meeting_id }}";
    const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
    const wsUrl = `${wsProtocol}//${window.location.host}/ws/meeting/${meetingId}/`;
    
    let socket = null;
    let mediaRecorder = null;
    let audioChunks = [];
    let isRecording = false;
    let isHost = {{ user.id == meeting.host.id|yesno:'true,false' }};
    let participantCount = 0;
    let activeSpeakers = new Map();
    let knownSpeakers = new Map();
    let transcriptSegments = [];

    // Initialize WebSocket connection
    function connectWebSocket() {
        socket = new WebSocket(wsUrl);
        
        socket.onopen = function(e) {
            console.log('WebSocket connected');
            
            socket.send(JSON.stringify({
                'type': 'join',
                'meeting_id': meetingId,
                'role': isHost ? 'host' : 'participant',
                'device_type': detectDeviceType()
            }));
            
            updateUI();
        };
        
        socket.onmessage = function(e) {
            const data = JSON.parse(e.data);
            handleWebSocketMessage(data);
        };
        
        socket.onclose = function(e) {
            console.log('WebSocket disconnected');
            setTimeout(connectWebSocket, 3000);
        };
        
        socket.onerror = function(e) {
            console.error('WebSocket error:', e);
        };
    }

    // Handle incoming WebSocket messages
    function handleWebSocketMessage(data) {
        switch(data.type) {
            case 'participant_joined':
                participantCount++;
                updateParticipantCount();
                break;
            case 'participant_left':
                participantCount = Math.max(0, participantCount - 1);
                updateParticipantCount();
                break;
            case 'recording_started':
                updateRecordingStatus(true);
                break;
            case 'recording_stopped':
                updateRecordingStatus(false);
                break;
            case 'transcript_update':
                updateTranscript(data.transcript);
                break;
            case 'participant_count':
                participantCount = data.count;
                updateParticipantCount();
                break;
            case 'speaker_identified':
                handleSpeakerIdentification(data.speaker);
                break;
            case 'speaker_unknown':
                handleUnknownSpeaker(data.speaker_id, data.transcript);
                break;
        }
    }

    // Update UI based on user role
    function updateUI() {
        const controlsContainer = document.getElementById('controlsContainer');
        
        if (isHost) {
            controlsContainer.innerHTML = `
                <button id="startRecordingBtn" class="control-btn control-btn-record">
                    <i class="fas fa-circle"></i>
                    Start Recording
                </button>
                <button id="stopRecordingBtn" class="control-btn control-btn-stop" style="display: none;">
                    <i class="fas fa-stop"></i>
                    Stop Recording
                </button>
                <button id="endMeetingBtn" class="control-btn control-btn-end">
                    <i class="fas fa-times"></i>
                    End Meeting
                </button>
            `;
            
            document.getElementById('startRecordingBtn').addEventListener('click', startRecording);
            document.getElementById('stopRecordingBtn').addEventListener('click', stopRecording);
            document.getElementById('endMeetingBtn').addEventListener('click', endMeeting);
            
            // Show speaker management
            document.getElementById('speakerManagement').classList.add('visible');
            
        } else {
            controlsContainer.innerHTML = `
                <div style="text-align: center;">
                    <div class="text-muted mb-10">
                        <i class="fas fa-eye"></i>
                        You're viewing this meeting
                    </div>
                    <button id="leaveMeetingBtn" class="control-btn control-btn-leave">
                        <i class="fas fa-sign-out-alt"></i>
                        Leave Meeting
                    </button>
                </div>
            `;
            
            document.getElementById('leaveMeetingBtn').addEventListener('click', leaveMeeting);
        }
    }

    // Update participant count
    function updateParticipantCount() {
        document.getElementById('participantCount').textContent = participantCount;
    }

    // Update recording status
    function updateRecordingStatus(recording) {
        const indicator = document.getElementById('recordingIndicator');
        const transcriptStatus = document.getElementById('transcriptStatus');
        
        if (recording) {
            indicator.classList.add('active');
            transcriptStatus.innerHTML = '<i class="fas fa-circle" style="color: #dc3545;"></i> Recording';
            
            if (isHost) {
                document.getElementById('startRecordingBtn').style.display = 'none';
                document.getElementById('stopRecordingBtn').style.display = 'inline-flex';
            }
            
            // Clear empty state
            const emptyState = document.querySelector('.empty-state');
            if (emptyState) {
                emptyState.remove();
            }
        } else {
            indicator.classList.remove('active');
            transcriptStatus.textContent = 'Stopped';
            
            if (isHost) {
                document.getElementById('startRecordingBtn').style.display = 'inline-flex';
                document.getElementById('stopRecordingBtn').style.display = 'none';
            }
        }
        
        isRecording = recording;
    }

    // Update transcript
    function updateTranscript(transcript) {
        const content = document.getElementById('transcriptContent');
        
        // Remove empty state if exists
        const emptyState = content.querySelector('.empty-state');
        if (emptyState) {
            emptyState.remove();
        }
        
        const segment = document.createElement('div');
        segment.className = 'transcript-segment';
        segment.setAttribute('data-segment-id', transcript.segment_id || Date.now());
        
        const speakerClass = transcript.speaker_confidence < 0.5 ? 'unknown' : '';
        const editButton = isHost && transcript.speaker_confidence < 0.5 ? 
            `<button class="edit-speaker-btn" onclick="editSpeaker(this)">
                <i class="fas fa-edit"></i>
            </button>` : '';
        
        segment.innerHTML = `
            <div class="speaker-label ${speakerClass}">
                <i class="fas fa-user"></i>
                ${transcript.speaker || 'Unknown Speaker'}
                ${editButton}
            </div>
            <div class="transcript-text">${transcript.text}</div>
        `;
        
        content.appendChild(segment);
        transcriptSegments.push(transcript);
        
        // Auto-scroll to bottom
        const container = document.querySelector('.transcript-container');
        container.scrollTop = container.scrollHeight;
    }
    
    // Handle speaker identification
    function handleSpeakerIdentification(speaker) {
        activeSpeakers.set(speaker.id, {
            name: speaker.name,
            confidence: speaker.confidence,
            last_seen: Date.now()
        });
        updateActiveSpeakers();
    }
    
    // Handle unknown speaker
    function handleUnknownSpeaker(speakerId, transcript) {
        if (!activeSpeakers.has(speakerId)) {
            activeSpeakers.set(speakerId, {
                name: `Speaker ${activeSpeakers.size + 1}`,
                confidence: 0.0,
                last_seen: Date.now()
            });
            updateActiveSpeakers();
        }
    }
    
    // Update active speakers display
    function updateActiveSpeakers() {
        const container = document.getElementById('activeSpeakers');
        container.innerHTML = '';
        
        if (activeSpeakers.size === 0) {
            container.innerHTML = `
                <div class="empty-state" style="grid-column: 1 / -1;">
                    <p class="text-muted">No active speakers yet</p>
                </div>
            `;
            return;
        }
        
        activeSpeakers.forEach((speaker, speakerId) => {
            const card = document.createElement('div');
            card.className = `speaker-card ${speaker.confidence > 0.7 ? 'verified' : 'unknown'}`;
            card.innerHTML = `
                <div class="speaker-info">
                    <i class="fas fa-user-circle"></i>
                    <div>
                        <div>${speaker.name}</div>
                        <div class="speaker-confidence">${Math.round(speaker.confidence * 100)}% confidence</div>
                    </div>
                </div>
                ${isHost ? `<button class="edit-speaker-btn" onclick="editSpeakerName('${speakerId}')">
                    <i class="fas fa-edit"></i>
                </button>` : ''}
            `;
            container.appendChild(card);
        });
    }
    
    // Edit speaker name inline
    function editSpeaker(button) {
        if (!isHost) return;
        
        const segment = button.closest('.transcript-segment');
        const speakerLabel = segment.querySelector('.speaker-label');
        const currentName = speakerLabel.textContent.replace('Edit', '').trim();
        
        const dropdown = document.createElement('select');
        dropdown.className = 'speaker-dropdown';
        
        // Add known speakers
        knownSpeakers.forEach((profile, email) => {
            const option = document.createElement('option');
            option.value = profile.name;
            option.textContent = profile.name;
            dropdown.appendChild(option);
        });
        
        // Add active speakers
        activeSpeakers.forEach((speaker, id) => {
            const option = document.createElement('option');
            option.value = speaker.name;
            option.textContent = speaker.name;
            dropdown.appendChild(option);
        });
        
        // Add "New Speaker" option
        const newOption = document.createElement('option');
        newOption.value = 'NEW';
        newOption.textContent = '+ New Speaker...';
        dropdown.appendChild(newOption);
        
        dropdown.value = currentName;
        dropdown.addEventListener('change', function() {
            if (this.value === 'NEW') {
                const newName = prompt('Enter speaker name:');
                if (newName) {
                    updateSegmentSpeaker(segment, newName);
                }
            } else {
                updateSegmentSpeaker(segment, this.value);
            }
            this.remove();
        });
        
        button.replaceWith(dropdown);
        dropdown.focus();
    }
    
    // Edit speaker name from active speakers
    function editSpeakerName(speakerId) {
        if (!isHost) return;
        
        const speaker = activeSpeakers.get(speakerId);
        const newName = prompt('Enter new name for speaker:', speaker.name);
        
        if (newName && newName.trim()) {
            speaker.name = newName.trim();
            activeSpeakers.set(speakerId, speaker);
            updateActiveSpeakers();
            
            // Update all transcript segments
            updateTranscriptSpeakerName(speaker.name, newName.trim());
            
            // Notify server
            if (socket && socket.readyState === WebSocket.OPEN) {
                socket.send(JSON.stringify({
                    'type': 'update_speaker_name',
                    'speaker_id': speakerId,
                    'new_name': newName.trim(),
                    'meeting_id': meetingId
                }));
            }
        }
    }
    
    // Update segment speaker
    function updateSegmentSpeaker(segment, newName) {
        const speakerLabel = segment.querySelector('.speaker-label');
        speakerLabel.innerHTML = `
            <i class="fas fa-user"></i>
            ${newName}
            <button class="edit-speaker-btn" onclick="editSpeaker(this)">
                <i class="fas fa-edit"></i>
            </button>
        `;
        speakerLabel.classList.remove('unknown');
        
        // Notify server
        const segmentId = segment.getAttribute('data-segment-id');
        if (socket && socket.readyState === WebSocket.OPEN) {
            socket.send(JSON.stringify({
                'type': 'update_segment_speaker',
                'segment_id': segmentId,
                'speaker_name': newName,
                'meeting_id': meetingId
            }));
        }
    }
    
    // Update transcript speaker name globally
    function updateTranscriptSpeakerName(oldName, newName) {
        const segments = document.querySelectorAll('.transcript-segment');
        segments.forEach(segment => {
            const speakerLabel = segment.querySelector('.speaker-label');
            if (speakerLabel.textContent.includes(oldName)) {
                speakerLabel.innerHTML = speakerLabel.innerHTML.replace(oldName, newName);
            }
        });
    }
    
    // Load known speakers
    async function loadKnownSpeakers() {
        try {
            const response = await fetch(`/api/meeting/${meetingId}/speakers/`);
            if (response.ok) {
                const data = await response.json();
                knownSpeakers.clear();
                data.known_speakers.forEach(speaker => {
                    knownSpeakers.set(speaker.email, {
                        name: speaker.name,
                        email: speaker.email,
                        job_title: speaker.job_title
                    });
                });
            }
        } catch (error) {
            console.error('Error loading speakers:', error);
        }
    }

    // Detect device type
    function detectDeviceType() {
        const userAgent = navigator.userAgent.toLowerCase();
        if (/iphone|ipod|android.*mobile|windows phone/i.test(userAgent)) {
            return 'mobile';
        } else if (/ipad|android(?!.*mobile)/i.test(userAgent)) {
            return 'tablet';
        }
        return 'desktop';
    }

    // Start recording (host only)
    async function startRecording() {
        if (!isHost) {
            alert('Only the host can control recording.');
            return;
        }
        
        try {
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            mediaRecorder = new MediaRecorder(stream);
            
            mediaRecorder.ondataavailable = function(event) {
                if (event.data.size > 0) {
                    audioChunks.push(event.data);
                }
            };
            
            mediaRecorder.onstop = function() {
                const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                uploadAudio(audioBlob);
                audioChunks = [];
            };
            
            mediaRecorder.start();
            updateRecordingStatus(true);
            
            // Notify all participants
            if (socket && socket.readyState === WebSocket.OPEN) {
                socket.send(JSON.stringify({
                    'type': 'recording_started',
                    'meeting_id': meetingId,
                    'host_recording': true
                }));
            }
        } catch (error) {
            console.error('Error starting recording:', error);
            alert('Could not access microphone. Please check permissions.');
        }
    }

    // Stop recording (host only)
    function stopRecording() {
        if (!isHost) return;
        
        if (mediaRecorder && isRecording) {
            mediaRecorder.stop();
            updateRecordingStatus(false);
            
            // Notify all participants
            if (socket && socket.readyState === WebSocket.OPEN) {
                socket.send(JSON.stringify({
                    'type': 'recording_stopped',
                    'meeting_id': meetingId
                }));
            }
            
            // Stop all tracks
            mediaRecorder.stream.getTracks().forEach(track => track.stop());
        }
    }

    // Upload audio to server
    async function uploadAudio(audioBlob) {
        const formData = new FormData();
        formData.append('audio', audioBlob, 'recording.webm');
        formData.append('meeting_id', meetingId);
        
        try {
            const response = await fetch('/api/upload-audio/', {
                method: 'POST',
                body: formData,
                headers: {
                    'X-CSRFToken': getCookie('csrftoken')
                }
            });
            
            if (response.ok) {
                console.log('Audio uploaded successfully');
            }
        } catch (error) {
            console.error('Error uploading audio:', error);
        }
    }

    // Get CSRF token
    function getCookie(name) {
        let cookieValue = null;
        if (document.cookie && document.cookie !== '') {
            const cookies = document.cookie.split(';');
            for (let i = 0; i < cookies.length; i++) {
                const cookie = cookies[i].trim();
                if (cookie.substring(0, name.length + 1) === (name + '=')) {
                    cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                    break;
                }
            }
        }
        return cookieValue;
    }

    // End meeting (host only)
    function endMeeting() {
        if (!isHost) return;
        
        if (confirm('Are you sure you want to end the meeting for everyone?')) {
            if (isRecording) {
                stopRecording();
            }
            
            if (socket) {
                socket.send(JSON.stringify({
                    'type': 'meeting_ended',
                    'meeting_id': meetingId
                }));
                socket.close();
            }
            
            window.location.href = '/dashboard/';
        }
    }

    // Leave meeting (participant)
    function leaveMeeting() {
        if (socket) {
            socket.send(JSON.stringify({
                'type': 'leave',
                'meeting_id': meetingId
            }));
            socket.close();
        }
        
        window.location.href = '/dashboard/';
    }

    // Initialize on page load
    document.addEventListener('DOMContentLoaded', function() {
        connectWebSocket();
        loadKnownSpeakers();
        
        // Speaker management event listeners
        const addBtn = document.getElementById('addSpeakerBtn');
        const refreshBtn = document.getElementById('refreshSpeakersBtn');
        
        if (addBtn) {
            addBtn.addEventListener('click', function() {
                const name = prompt('Enter speaker name:');
                if (name && name.trim()) {
                    const speakerId = 'manual_' + Date.now();
                    activeSpeakers.set(speakerId, {
                        name: name.trim(),
                        confidence: 1.0,
                        last_seen: Date.now()
                    });
                    updateActiveSpeakers();
                    
                    // Notify server
                    if (socket && socket.readyState === WebSocket.OPEN) {
                        socket.send(JSON.stringify({
                            'type': 'add_manual_speaker',
                            'speaker_id': speakerId,
                            'speaker_name': name.trim(),
                            'meeting_id': meetingId
                        }));
                    }
                }
            });
        }
        
        if (refreshBtn) {
            refreshBtn.addEventListener('click', function() {
                loadKnownSpeakers();
                
                // Request refresh from server
                if (socket && socket.readyState === WebSocket.OPEN) {
                    socket.send(JSON.stringify({
                        'type': 'refresh_speakers',
                        'meeting_id': meetingId
                    }));
                }
            });
        }
        
        // Request notification permission
        if ('Notification' in window && Notification.permission === 'default') {
            Notification.requestPermission();
        }
    });

    // Handle page unload
    window.addEventListener('beforeunload', function() {
        if (isRecording) {
            stopRecording();
        }
        if (socket) {
            socket.close();
        }
    });
</script>
{% endblock %}