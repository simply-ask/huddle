{% extends 'base.html' %}
{% load static %}

{% block title %}Meeting: {{ meeting.title|default:meeting.meeting_id }}{% endblock %}

{% block extra_css %}
<style>
    /* Meeting room styles - clean Toaster UI */
    .meeting-container {
        max-width: 1200px;
        margin: 0 auto;
        padding-bottom: 100px; /* Space for fixed controls */
    }
    
    /* Header section */
    .meeting-header {
        margin-bottom: 32px;
    }
    
    .meeting-title {
        font-size: 28px;
        font-weight: 300;
        margin-bottom: 8px;
    }
    
    /* Recording indicator */
    .recording-indicator {
        position: fixed;
        top: 20px;
        right: 20px;
        background: #dc3545;
        color: white;
        padding: 12px 20px;
        border-radius: 24px;
        display: none;
        align-items: center;
        gap: 10px;
        z-index: 1000;
        animation: fadeIn 0.3s ease;
    }
    
    .recording-indicator.active {
        display: flex;
    }
    
    .recording-dot {
        width: 10px;
        height: 10px;
        background: white;
        border-radius: 50%;
        animation: pulse 1.5s infinite;
    }
    
    @keyframes pulse {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.3; }
    }
    
    @keyframes fadeIn {
        from { opacity: 0; transform: translateY(-10px); }
        to { opacity: 1; transform: translateY(0); }
    }
    
    /* Participants section */
    .participants-card {
        background: rgba(255, 255, 255, 0.05);
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 8px;
        padding: 24px;
        margin-bottom: 24px;
        backdrop-filter: blur(10px);
    }
    
    .host-info {
        display: flex;
        align-items: center;
        gap: 16px;
    }
    
    .host-icon {
        width: 48px;
        height: 48px;
        background: rgba(100, 169, 63, 0.2);
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 24px;
    }
    
    .host-badge {
        background: #64a93f;
        color: white;
        padding: 4px 12px;
        border-radius: 20px;
        font-size: 11px;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.5px;
    }
    
    /* Speaker management */
    .speaker-management {
        background: rgba(255, 255, 255, 0.05);
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 8px;
        padding: 24px;
        margin-bottom: 24px;
        display: none;
    }
    
    .speaker-management.visible {
        display: block;
        animation: fadeIn 0.3s ease;
    }
    
    .speaker-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
        gap: 12px;
        margin: 20px 0;
    }
    
    .speaker-card {
        background: rgba(255, 255, 255, 0.08);
        border: 1px solid rgba(255, 255, 255, 0.15);
        border-radius: 6px;
        padding: 12px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        transition: all 0.2s;
    }
    
    .speaker-card:hover {
        background: rgba(255, 255, 255, 0.12);
        transform: translateY(-1px);
    }
    
    .speaker-card.verified {
        border-color: #64a93f;
        background: rgba(100, 169, 63, 0.1);
    }
    
    .speaker-card.unknown {
        border-color: #ffc107;
        background: rgba(255, 193, 7, 0.1);
    }
    
    .speaker-info {
        display: flex;
        align-items: center;
        gap: 8px;
    }
    
    .speaker-confidence {
        font-size: 12px;
        color: rgba(255, 255, 255, 0.6);
    }
    
    .edit-speaker-btn {
        background: transparent;
        border: none;
        color: rgba(255, 255, 255, 0.7);
        cursor: pointer;
        padding: 4px;
        transition: color 0.2s;
    }
    
    .edit-speaker-btn:hover {
        color: #fff;
    }
    
    /* Transcript section */
    .transcript-container {
        background: rgba(255, 255, 255, 0.05);
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 8px;
        padding: 24px;
        margin-bottom: 24px;
        max-height: 400px;
        overflow-y: auto;
    }
    
    .transcript-container::-webkit-scrollbar {
        width: 8px;
    }
    
    .transcript-container::-webkit-scrollbar-track {
        background: rgba(255, 255, 255, 0.05);
        border-radius: 4px;
    }
    
    .transcript-container::-webkit-scrollbar-thumb {
        background: rgba(255, 255, 255, 0.2);
        border-radius: 4px;
    }
    
    .transcript-container::-webkit-scrollbar-thumb:hover {
        background: rgba(255, 255, 255, 0.3);
    }
    
    .transcript-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 20px;
    }
    
    .transcript-title {
        font-size: 18px;
        font-weight: 500;
    }
    
    .transcript-status {
        font-size: 12px;
        color: rgba(255, 255, 255, 0.6);
    }
    
    .transcript-segment {
        margin: 16px 0;
        padding: 16px;
        background: rgba(255, 255, 255, 0.03);
        border-left: 3px solid rgba(255, 255, 255, 0.1);
        border-radius: 4px;
        transition: all 0.2s;
    }
    
    .transcript-segment:hover {
        background: rgba(255, 255, 255, 0.05);
        border-left-color: #64a93f;
    }
    
    .speaker-label {
        font-weight: 500;
        margin-bottom: 8px;
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 14px;
    }
    
    .speaker-label.unknown {
        color: #ffc107;
    }
    
    .transcript-text {
        color: rgba(255, 255, 255, 0.9);
        line-height: 1.6;
    }
    
    .speaker-dropdown {
        background: rgba(255, 255, 255, 0.9);
        color: #0a2134;
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 4px;
        padding: 4px 8px;
        font-size: 13px;
        margin-left: 8px;
    }
    
    /* Fixed controls bar */
    .controls-bar {
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        background: rgba(10, 33, 52, 0.95);
        backdrop-filter: blur(20px);
        border-top: 1px solid rgba(255, 255, 255, 0.1);
        padding: 20px;
        z-index: 999;
    }
    
    .controls-container {
        max-width: 1200px;
        margin: 0 auto;
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 16px;
    }
    
    /* Participation mode toggle */
    .participation-toggle {
        display: flex;
        align-items: center;
        gap: 12px;
        font-size: 14px;
        color: rgba(255, 255, 255, 0.8);
    }
    
    .toggle-switch {
        position: relative;
        width: 60px;
        height: 30px;
        background: rgba(255, 255, 255, 0.2);
        border-radius: 15px;
        cursor: pointer;
        transition: all 0.3s;
    }
    
    .toggle-switch.remote {
        background: #64a93f;
    }
    
    .toggle-handle {
        position: absolute;
        top: 3px;
        left: 3px;
        width: 24px;
        height: 24px;
        background: white;
        border-radius: 50%;
        transition: all 0.3s;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }
    
    .toggle-switch.remote .toggle-handle {
        transform: translateX(30px);
    }
    
    /* Remote controls */
    .remote-controls {
        display: none;
        align-items: center;
        gap: 16px;
        flex: 1;
        justify-content: center;
    }
    
    .remote-controls.active {
        display: flex;
    }
    
    .mic-control {
        display: flex;
        align-items: center;
        gap: 8px;
        cursor: pointer;
        padding: 10px 16px;
        border-radius: 6px;
        background: rgba(255, 255, 255, 0.1);
        transition: all 0.2s;
        border: 1px solid transparent;
    }
    
    .mic-control:hover {
        background: rgba(255, 255, 255, 0.15);
    }
    
    .mic-control.muted {
        background: rgba(220, 53, 69, 0.2);
        color: #dc3545;
        border-color: rgba(220, 53, 69, 0.4);
    }
    
    .volume-control {
        display: flex;
        align-items: center;
        gap: 8px;
    }
    
    .volume-slider {
        width: 80px;
        height: 4px;
        background: rgba(255, 255, 255, 0.2);
        border-radius: 2px;
        outline: none;
        -webkit-appearance: none;
    }
    
    .volume-slider::-webkit-slider-thumb {
        width: 16px;
        height: 16px;
        background: #64a93f;
        border-radius: 50%;
        cursor: pointer;
        -webkit-appearance: none;
    }
    
    .connection-status {
        display: flex;
        align-items: center;
        gap: 6px;
        font-size: 12px;
        color: rgba(255, 255, 255, 0.6);
    }
    
    .status-dot {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        background: #64a93f;
        animation: pulse 2s infinite;
    }
    
    .status-dot.disconnected {
        background: #dc3545;
        animation: none;
    }
    
    .recording-controls {
        display: flex;
        align-items: center;
        gap: 16px;
    }
    
    /* Remote participants list */
    .remote-participants-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
        gap: 12px;
        margin-top: 8px;
    }
    
    .remote-participant-card {
        background: rgba(255, 255, 255, 0.05);
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 6px;
        padding: 12px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 8px;
    }
    
    .remote-participant-info {
        display: flex;
        align-items: center;
        gap: 8px;
        flex: 1;
        min-width: 0;
    }
    
    .remote-participant-avatar {
        width: 24px;
        height: 24px;
        background: rgba(100, 169, 63, 0.2);
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 12px;
        color: #64a93f;
    }
    
    .remote-participant-name {
        font-size: 13px;
        font-weight: 500;
        color: rgba(255, 255, 255, 0.9);
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }
    
    .remote-participant-status {
        display: flex;
        align-items: center;
        gap: 4px;
        font-size: 11px;
        color: rgba(255, 255, 255, 0.6);
    }
    
    .remote-participant-controls {
        display: flex;
        gap: 4px;
    }
    
    .participant-control-btn {
        background: none;
        border: none;
        color: rgba(255, 255, 255, 0.6);
        cursor: pointer;
        padding: 4px;
        border-radius: 3px;
        font-size: 12px;
        transition: all 0.2s;
    }
    
    .participant-control-btn:hover {
        background: rgba(255, 255, 255, 0.1);
        color: rgba(255, 255, 255, 0.9);
    }
    
    .participant-control-btn.muted {
        color: #dc3545;
    }
    
    .control-btn {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        padding: 12px 24px;
        border: none;
        border-radius: 8px;
        font-size: 15px;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s;
        color: white;
    }
    
    .control-btn-record {
        background: #dc3545;
    }
    
    .control-btn-record:hover {
        background: #c82333;
        transform: translateY(-1px);
    }
    
    .control-btn-stop {
        background: #64a93f;
    }
    
    .control-btn-stop:hover {
        background: #548832;
        transform: translateY(-1px);
    }
    
    .control-btn-leave {
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
    }
    
    .control-btn-leave:hover {
        background: rgba(255, 255, 255, 0.2);
    }
    
    .control-btn-end {
        background: rgba(220, 53, 69, 0.2);
        border: 1px solid #dc3545;
        color: #ff6b6b;
    }
    
    .control-btn-end:hover {
        background: rgba(220, 53, 69, 0.3);
    }
    
    /* Empty state */
    .empty-state {
        text-align: center;
        padding: 40px;
        color: rgba(255, 255, 255, 0.5);
    }
    
    .empty-state i {
        font-size: 48px;
        margin-bottom: 16px;
        opacity: 0.5;
    }
    
    /* Role badge */
    .role-badge {
        position: absolute;
        top: 20px;
        left: 20px;
        padding: 8px 16px;
        border-radius: 20px;
        font-size: 12px;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.5px;
    }
    
    .role-badge.host {
        background: #64a93f;
        color: white;
    }
    
    .role-badge.participant {
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
        color: rgba(255, 255, 255, 0.8);
    }
    
    /* Responsive */
    @media (max-width: 768px) {
        .meeting-container {
            padding-bottom: 120px;
        }
        
        .controls-container {
            flex-wrap: wrap;
        }
        
        .speaker-grid {
            grid-template-columns: 1fr;
        }
    }
</style>
{% endblock %}

{% block content %}
<div class="meeting-container">
    <!-- Role indicator -->
    {% if user.id == meeting.host.id %}
    <div class="role-badge host" id="roleBadge">
        <i class="fas fa-crown"></i>
        Host
    </div>
    {% else %}
    <div class="role-badge participant" id="roleBadge">
        <i class="fas fa-eye"></i>
        Viewer
    </div>
    {% endif %}
    
    <!-- Recording indicator -->
    <div class="recording-indicator" id="recordingIndicator">
        <div class="recording-dot"></div>
        <span>Recording</span>
    </div>
    
    <!-- Simple meeting header - Toaster UI -->
    <div class="meeting-header" style="text-align: center; padding: 40px 20px; background: rgba(255, 255, 255, 0.05); margin-bottom: 32px; border-radius: 12px;">
        <h1 style="font-size: 32px; font-weight: 300; margin-bottom: 16px; color: #fff;">
            {{ meeting.title|default:"Meeting Room" }}
        </h1>
        <div style="display: flex; justify-content: center; gap: 24px; flex-wrap: wrap;">
            {% if meeting.scheduled_start %}
                <div class="text-muted" style="font-size: 16px;">
                    <i class="fas fa-calendar" style="margin-right: 8px; color: #64a93f;"></i>
                    {{ meeting.scheduled_start|date:"M j, Y at g:i A" }}
                </div>
            {% endif %}
            {% if meeting.location %}
                <div class="text-muted" style="font-size: 16px;">
                    <i class="fas fa-map-marker-alt" style="margin-right: 8px; color: #64a93f;"></i>
                    {{ meeting.location }}
                </div>
            {% endif %}
            {% if not meeting.scheduled_start and not meeting.location %}
                <div class="text-muted" style="font-size: 16px;">
                    <i class="fas fa-video" style="margin-right: 8px; color: #64a93f;"></i>
                    Live Meeting Session
                </div>
            {% endif %}
        </div>
    </div>
    
    <!-- Simple status card - Toaster UI -->
    <div class="card" style="text-align: center; margin-bottom: 24px;">
        <div style="display: flex; align-items: center; justify-content: center; gap: 24px; flex-wrap: wrap;">
            <div style="display: flex; align-items: center; gap: 12px;">
                <div style="width: 40px; height: 40px; background: #64a93f; border-radius: 50%; display: flex; align-items: center; justify-content: center;">
                    <i class="fas fa-microphone" style="color: #fff; font-size: 18px;"></i>
                </div>
                <div style="text-align: left;">
                    <div style="font-weight: 500;">{{ meeting.host.get_full_name|default:meeting.host.username }}</div>
                    <div class="text-muted text-small">Host</div>
                </div>
            </div>
            
            <div style="display: flex; align-items: center; gap: 12px;">
                <div style="width: 40px; height: 40px; background: rgba(255, 255, 255, 0.1); border-radius: 50%; display: flex; align-items: center; justify-content: center;">
                    <i class="fas fa-users" style="color: #fff; font-size: 18px;"></i>
                </div>
                <div style="text-align: left;">
                    <div style="font-weight: 500;"><span id="participantCount">0</span> joined</div>
                    <div class="text-muted text-small">Participants</div>
                </div>
            </div>
        </div>
        
        <!-- Remote participants (admin only) -->
        <div id="remoteParticipants" style="display: none; margin-top: 20px; padding-top: 20px; border-top: 1px solid rgba(255, 255, 255, 0.1);">
            <div id="remoteParticipantsList" class="remote-participants-grid">
                <!-- Remote participants will be populated dynamically -->
            </div>
        </div>
    </div>
    
    <!-- Speaker management (host only) -->
    <div class="speaker-management" id="speakerManagement">
        <div class="flex-between mb-20">
            <div>
                <h3 style="font-size: 18px; font-weight: 500; margin-bottom: 4px;">
                    <i class="fas fa-users"></i> Active Speakers
                </h3>
                <div class="text-small text-muted">Manage speaker identification</div>
            </div>
            <div class="flex gap-10">
                <button class="btn btn-small btn-secondary" id="addSpeakerBtn">
                    <i class="fas fa-plus"></i>
                    Add
                </button>
                <button class="btn btn-small btn-secondary" id="refreshSpeakersBtn">
                    <i class="fas fa-sync"></i>
                    Refresh
                </button>
            </div>
        </div>
        
        <div class="speaker-grid" id="activeSpeakers">
            <!-- Speaker cards will be populated dynamically -->
        </div>
    </div>
    
    <!-- Simple transcript - Toaster UI -->
    <div class="card">
        <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 20px;">
            <h3 style="font-size: 18px; font-weight: 500; margin: 0;">
                <i class="fas fa-closed-captioning" style="margin-right: 8px; color: #64a93f;"></i>
                Live Transcript
            </h3>
            <div class="text-muted text-small" id="transcriptStatus">Ready</div>
        </div>
        
        <div id="transcriptContent" style="min-height: 120px; max-height: 300px; overflow-y: auto; padding: 16px; background: rgba(0, 0, 0, 0.2); border-radius: 6px; border: 1px solid rgba(255, 255, 255, 0.1);">
            <div class="empty-state" style="text-align: center; color: rgba(255, 255, 255, 0.5); padding: 20px;">
                <i class="fas fa-microphone" style="font-size: 32px; margin-bottom: 12px; opacity: 0.3;"></i>
                <p style="margin: 0; font-size: 14px;">Start recording to see live transcript</p>
            </div>
        </div>
    </div>
</div>

<!-- Fixed controls bar -->
<div class="controls-bar">
    <div class="controls-container" id="controlsContainer">
        <!-- Recording controls (in-person mode) -->
        <div class="recording-controls" id="recordingControls">
            <button id="recordBtn" class="control-btn">
                <i class="fas fa-circle" id="recordIcon"></i>
                <span id="recordText">Start Recording</span>
            </button>
            <div id="recordingTimer" class="recording-timer" style="display: none;">00:00</div>
        </div>
        
        <!-- Remote controls (remote mode) -->
        <div class="remote-controls" id="remoteControls">
            <div class="mic-control" id="micControl">
                <i class="fas fa-microphone" id="micIcon"></i>
                <span id="micText">Microphone</span>
            </div>
            
            <div class="volume-control">
                <i class="fas fa-volume-up"></i>
                <input type="range" class="volume-slider" id="volumeSlider" min="0" max="100" value="50">
            </div>
            
            <div class="connection-status">
                <div class="status-dot" id="connectionDot"></div>
                <span id="connectionText">Connected</span>
            </div>
        </div>
        
        <!-- Participation mode toggle -->
        <div class="participation-toggle">
            <span>In Person</span>
            <div class="toggle-switch" id="participationToggle">
                <div class="toggle-handle"></div>
            </div>
            <span>Remote</span>
        </div>
    </div>
</div>

<script>
    const meetingId = "{{ meeting.meeting_id }}";
    const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
    const wsUrl = `${wsProtocol}//${window.location.host}/ws/meeting/${meetingId}/`;
    
    let socket = null;
    let mediaRecorder = null;
    let audioChunks = [];
    let isRecording = false;
    let isHost = {{ user.id == meeting.host.id|yesno:'true,false' }};
    let participantCount = 0;
    let activeSpeakers = new Map();
    let isRemoteMode = false;
    let remoteAudioStream = null;
    let remoteMediaRecorder = null;
    let isMuted = false;
    let remoteAudio = null;
    
    // Check if user accessed via remote link
    const urlParams = new URLSearchParams(window.location.search);
    if (urlParams.get('mode') === 'remote') {
        isRemoteMode = true;
    }
    let knownSpeakers = new Map();
    let transcriptSegments = [];

    // Initialize WebSocket connection
    function connectWebSocket() {
        socket = new WebSocket(wsUrl);
        
        socket.onopen = function(e) {
            console.log('WebSocket connected');
            
            socket.send(JSON.stringify({
                'type': 'join',
                'meeting_id': meetingId,
                'role': isHost ? 'host' : 'participant',
                'device_type': detectDeviceType()
            }));
            
            updateUI();
        };
        
        socket.onmessage = function(e) {
            const data = JSON.parse(e.data);
            handleWebSocketMessage(data);
        };
        
        socket.onclose = function(e) {
            console.log('WebSocket disconnected');
            setTimeout(connectWebSocket, 3000);
        };
        
        socket.onerror = function(e) {
            console.error('WebSocket error:', e);
        };
    }

    // Handle incoming WebSocket messages
    function handleWebSocketMessage(data) {
        switch(data.type) {
            case 'participant_joined':
                participantCount++;
                updateParticipantCount();
                // Check if it's a remote participant
                if (data.participant_name && data.participant_id) {
                    addRemoteParticipant(data.participant_id, data.participant_name);
                }
                break;
            case 'participant_left':
                participantCount = Math.max(0, participantCount - 1);
                updateParticipantCount();
                // Remove from remote participants if applicable
                if (data.participant_id) {
                    removeRemoteParticipant(data.participant_id);
                }
                break;
            case 'recording_started':
                updateRecordingStatus(true);
                break;
            case 'recording_stopped':
                updateRecordingStatus(false);
                break;
            case 'transcript_update':
                updateTranscript(data.transcript);
                break;
            case 'participant_count':
                participantCount = data.count;
                updateParticipantCount();
                break;
            case 'speaker_identified':
                handleSpeakerIdentification(data.speaker);
                break;
            case 'speaker_unknown':
                handleUnknownSpeaker(data.speaker_id, data.transcript);
                break;
            case 'remote_audio_message':
                handleRemoteAudioMessage(data);
                break;
            case 'audio_stream_request_message':
                handleAudioStreamRequest(data);
                break;
            case 'mic_status_message':
                handleMicStatusMessage(data);
                break;
        }
    }

    // Update UI based on user role - ADMIN-ONLY RECORDING
    function updateUI() {
        const controlsContainer = document.getElementById('controlsContainer');

        if (isHost) {
            // HOST/ADMIN: Full recording controls
            controlsContainer.innerHTML = `
                <button id="startRecordingBtn" class="control-btn control-btn-record">
                    <i class="fas fa-circle"></i>
                    Start Recording
                </button>
                <button id="stopRecordingBtn" class="control-btn control-btn-stop" style="display: none;">
                    <i class="fas fa-stop"></i>
                    Stop Recording
                </button>
                <button id="endMeetingBtn" class="control-btn control-btn-end">
                    <i class="fas fa-times"></i>
                    End Meeting
                </button>
            `;

            document.getElementById('startRecordingBtn').addEventListener('click', startRecording);
            document.getElementById('stopRecordingBtn').addEventListener('click', stopRecording);
            document.getElementById('endMeetingBtn').addEventListener('click', endMeeting);

            // Show speaker management
            document.getElementById('speakerManagement').classList.add('visible');

        } else {
            // PARTICIPANT: View-only mode
            controlsContainer.innerHTML = `
                <div style="text-align: center; width: 100%;">
                    <div class="text-muted mb-10" style="font-size: 14px; opacity: 0.8;">
                        <i class="fas fa-eye" style="margin-right: 8px;"></i>
                        Viewing meeting - Only the admin can record
                    </div>
                    <button id="leaveMeetingBtn" class="control-btn control-btn-leave">
                        <i class="fas fa-sign-out-alt"></i>
                        Leave Meeting
                    </button>
                </div>
            `;

            document.getElementById('leaveMeetingBtn').addEventListener('click', leaveMeeting);

            // Hide speaker management for participants
            document.getElementById('speakerManagement').style.display = 'none';
        }
    }

    // Update participant count
    function updateParticipantCount() {
        document.getElementById('participantCount').textContent = participantCount;
    }

    // Update recording status
    function updateRecordingStatus(recording) {
        const indicator = document.getElementById('recordingIndicator');
        const transcriptStatus = document.getElementById('transcriptStatus');
        
        if (recording) {
            indicator.classList.add('active');
            transcriptStatus.innerHTML = '<i class="fas fa-circle" style="color: #dc3545;"></i> Recording';
            
            if (isHost) {
                document.getElementById('startRecordingBtn').style.display = 'none';
                document.getElementById('stopRecordingBtn').style.display = 'inline-flex';
            }
            
            // Clear empty state
            const emptyState = document.querySelector('.empty-state');
            if (emptyState) {
                emptyState.remove();
            }
        } else {
            indicator.classList.remove('active');
            transcriptStatus.textContent = 'Stopped';
            
            if (isHost) {
                document.getElementById('startRecordingBtn').style.display = 'inline-flex';
                document.getElementById('stopRecordingBtn').style.display = 'none';
            }
        }
        
        isRecording = recording;
    }

    // Update transcript
    function updateTranscript(transcript) {
        const content = document.getElementById('transcriptContent');
        
        // Remove empty state if exists
        const emptyState = content.querySelector('.empty-state');
        if (emptyState) {
            emptyState.remove();
        }
        
        const segment = document.createElement('div');
        segment.className = 'transcript-segment';
        segment.setAttribute('data-segment-id', transcript.segment_id || Date.now());
        
        const speakerClass = transcript.speaker_confidence < 0.5 ? 'unknown' : '';
        const editButton = isHost && transcript.speaker_confidence < 0.5 ? 
            `<button class="edit-speaker-btn" onclick="editSpeaker(this)">
                <i class="fas fa-edit"></i>
            </button>` : '';
        
        segment.innerHTML = `
            <div class="speaker-label ${speakerClass}">
                <i class="fas fa-user"></i>
                ${transcript.speaker || 'Unknown Speaker'}
                ${editButton}
            </div>
            <div class="transcript-text">${transcript.text}</div>
        `;
        
        content.appendChild(segment);
        transcriptSegments.push(transcript);
        
        // Auto-scroll to bottom
        const container = document.querySelector('.transcript-container');
        container.scrollTop = container.scrollHeight;
    }
    
    // Handle speaker identification
    function handleSpeakerIdentification(speaker) {
        activeSpeakers.set(speaker.id, {
            name: speaker.name,
            confidence: speaker.confidence,
            last_seen: Date.now()
        });
        updateActiveSpeakers();
    }
    
    // Handle unknown speaker
    function handleUnknownSpeaker(speakerId, transcript) {
        if (!activeSpeakers.has(speakerId)) {
            activeSpeakers.set(speakerId, {
                name: `Speaker ${activeSpeakers.size + 1}`,
                confidence: 0.0,
                last_seen: Date.now()
            });
            updateActiveSpeakers();
        }
    }
    
    // Update active speakers display
    function updateActiveSpeakers() {
        const container = document.getElementById('activeSpeakers');
        container.innerHTML = '';
        
        if (activeSpeakers.size === 0) {
            container.innerHTML = `
                <div class="empty-state" style="grid-column: 1 / -1;">
                    <p class="text-muted">No active speakers yet</p>
                </div>
            `;
            return;
        }
        
        activeSpeakers.forEach((speaker, speakerId) => {
            const card = document.createElement('div');
            card.className = `speaker-card ${speaker.confidence > 0.7 ? 'verified' : 'unknown'}`;
            card.innerHTML = `
                <div class="speaker-info">
                    <i class="fas fa-user-circle"></i>
                    <div>
                        <div>${speaker.name}</div>
                        <div class="speaker-confidence">${Math.round(speaker.confidence * 100)}% confidence</div>
                    </div>
                </div>
                ${isHost ? `<button class="edit-speaker-btn" onclick="editSpeakerName('${speakerId}')">
                    <i class="fas fa-edit"></i>
                </button>` : ''}
            `;
            container.appendChild(card);
        });
    }
    
    // Edit speaker name inline
    function editSpeaker(button) {
        if (!isHost) return;
        
        const segment = button.closest('.transcript-segment');
        const speakerLabel = segment.querySelector('.speaker-label');
        const currentName = speakerLabel.textContent.replace('Edit', '').trim();
        
        const dropdown = document.createElement('select');
        dropdown.className = 'speaker-dropdown';
        
        // Add known speakers
        knownSpeakers.forEach((profile, email) => {
            const option = document.createElement('option');
            option.value = profile.name;
            option.textContent = profile.name;
            dropdown.appendChild(option);
        });
        
        // Add active speakers
        activeSpeakers.forEach((speaker, id) => {
            const option = document.createElement('option');
            option.value = speaker.name;
            option.textContent = speaker.name;
            dropdown.appendChild(option);
        });
        
        // Add "New Speaker" option
        const newOption = document.createElement('option');
        newOption.value = 'NEW';
        newOption.textContent = '+ New Speaker...';
        dropdown.appendChild(newOption);
        
        dropdown.value = currentName;
        dropdown.addEventListener('change', function() {
            if (this.value === 'NEW') {
                const newName = prompt('Enter speaker name:');
                if (newName) {
                    updateSegmentSpeaker(segment, newName);
                }
            } else {
                updateSegmentSpeaker(segment, this.value);
            }
            this.remove();
        });
        
        button.replaceWith(dropdown);
        dropdown.focus();
    }
    
    // Edit speaker name from active speakers
    function editSpeakerName(speakerId) {
        if (!isHost) return;
        
        const speaker = activeSpeakers.get(speakerId);
        const newName = prompt('Enter new name for speaker:', speaker.name);
        
        if (newName && newName.trim()) {
            speaker.name = newName.trim();
            activeSpeakers.set(speakerId, speaker);
            updateActiveSpeakers();
            
            // Update all transcript segments
            updateTranscriptSpeakerName(speaker.name, newName.trim());
            
            // Notify server
            if (socket && socket.readyState === WebSocket.OPEN) {
                socket.send(JSON.stringify({
                    'type': 'update_speaker_name',
                    'speaker_id': speakerId,
                    'new_name': newName.trim(),
                    'meeting_id': meetingId
                }));
            }
        }
    }
    
    // Update segment speaker
    function updateSegmentSpeaker(segment, newName) {
        const speakerLabel = segment.querySelector('.speaker-label');
        speakerLabel.innerHTML = `
            <i class="fas fa-user"></i>
            ${newName}
            <button class="edit-speaker-btn" onclick="editSpeaker(this)">
                <i class="fas fa-edit"></i>
            </button>
        `;
        speakerLabel.classList.remove('unknown');
        
        // Notify server
        const segmentId = segment.getAttribute('data-segment-id');
        if (socket && socket.readyState === WebSocket.OPEN) {
            socket.send(JSON.stringify({
                'type': 'update_segment_speaker',
                'segment_id': segmentId,
                'speaker_name': newName,
                'meeting_id': meetingId
            }));
        }
    }
    
    // Update transcript speaker name globally
    function updateTranscriptSpeakerName(oldName, newName) {
        const segments = document.querySelectorAll('.transcript-segment');
        segments.forEach(segment => {
            const speakerLabel = segment.querySelector('.speaker-label');
            if (speakerLabel.textContent.includes(oldName)) {
                speakerLabel.innerHTML = speakerLabel.innerHTML.replace(oldName, newName);
            }
        });
    }
    
    // Load known speakers
    async function loadKnownSpeakers() {
        try {
            const response = await fetch(`/api/meeting/${meetingId}/speakers/`);
            if (response.ok) {
                const data = await response.json();
                knownSpeakers.clear();
                data.known_speakers.forEach(speaker => {
                    knownSpeakers.set(speaker.email, {
                        name: speaker.name,
                        email: speaker.email,
                        job_title: speaker.job_title
                    });
                });
            }
        } catch (error) {
            console.error('Error loading speakers:', error);
        }
    }

    // Detect device type
    function detectDeviceType() {
        const userAgent = navigator.userAgent.toLowerCase();
        if (/iphone|ipod|android.*mobile|windows phone/i.test(userAgent)) {
            return 'mobile';
        } else if (/ipad|android(?!.*mobile)/i.test(userAgent)) {
            return 'tablet';
        }
        return 'desktop';
    }

    // Start recording (host only)
    async function startRecording() {
        if (!isHost) {
            alert('Only the host can control recording.');
            return;
        }
        
        try {
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            mediaRecorder = new MediaRecorder(stream);
            
            mediaRecorder.ondataavailable = function(event) {
                if (event.data.size > 0) {
                    audioChunks.push(event.data);
                }
            };
            
            mediaRecorder.onstop = function() {
                const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                uploadAudio(audioBlob);
                audioChunks = [];
            };
            
            mediaRecorder.start();
            updateRecordingStatus(true);
            
            // Notify all participants
            if (socket && socket.readyState === WebSocket.OPEN) {
                socket.send(JSON.stringify({
                    'type': 'recording_started',
                    'meeting_id': meetingId,
                    'host_recording': true
                }));
            }
        } catch (error) {
            console.error('Error starting recording:', error);
            alert('Could not access microphone. Please check permissions.');
        }
    }

    // Stop recording (host only)
    function stopRecording() {
        if (!isHost) return;
        
        if (mediaRecorder && isRecording) {
            mediaRecorder.stop();
            updateRecordingStatus(false);
            
            // Notify all participants
            if (socket && socket.readyState === WebSocket.OPEN) {
                socket.send(JSON.stringify({
                    'type': 'recording_stopped',
                    'meeting_id': meetingId
                }));
            }
            
            // Stop all tracks
            mediaRecorder.stream.getTracks().forEach(track => track.stop());
        }
    }

    // Upload audio to server - ADMIN ONLY
    async function uploadAudio(audioBlob) {
        if (!isHost) {
            console.error('Upload blocked: Only admin can upload recordings');
            return;
        }

        const formData = new FormData();
        formData.append('audio_file', audioBlob, 'recording.webm');
        formData.append('meeting_id', meetingId);
        formData.append('session_id', '{{ user.id }}'); // Use user ID as session ID for authenticated users

        try {
            const response = await fetch('/api/upload-audio/', {
                method: 'POST',
                body: formData,
                headers: {
                    'X-CSRFToken': getCookie('csrftoken')
                }
            });

            if (response.ok) {
                console.log('Audio uploaded successfully');
                const data = await response.json();
                console.log('Recording queued for processing:', data.recording_id);
            } else {
                const errorData = await response.json();
                console.error('Upload failed:', errorData.error);
                if (response.status === 403) {
                    alert('Only the meeting admin can record audio.');
                }
            }
        } catch (error) {
            console.error('Error uploading audio:', error);
        }
    }

    // Get CSRF token
    function getCookie(name) {
        let cookieValue = null;
        if (document.cookie && document.cookie !== '') {
            const cookies = document.cookie.split(';');
            for (let i = 0; i < cookies.length; i++) {
                const cookie = cookies[i].trim();
                if (cookie.substring(0, name.length + 1) === (name + '=')) {
                    cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                    break;
                }
            }
        }
        return cookieValue;
    }

    // End meeting (host only)
    function endMeeting() {
        if (!isHost) return;
        
        if (confirm('Are you sure you want to end the meeting for everyone?')) {
            if (isRecording) {
                stopRecording();
            }
            
            if (socket) {
                socket.send(JSON.stringify({
                    'type': 'meeting_ended',
                    'meeting_id': meetingId
                }));
                socket.close();
            }
            
            window.location.href = '/dashboard/';
        }
    }

    // Leave meeting (participant)
    function leaveMeeting() {
        if (socket) {
            socket.send(JSON.stringify({
                'type': 'leave',
                'meeting_id': meetingId
            }));
            socket.close();
        }
        
        window.location.href = '/dashboard/';
    }

    // Initialize on page load
    document.addEventListener('DOMContentLoaded', function() {
        connectWebSocket();
        loadKnownSpeakers();
        
        // Speaker management event listeners
        const addBtn = document.getElementById('addSpeakerBtn');
        const refreshBtn = document.getElementById('refreshSpeakersBtn');
        
        if (addBtn) {
            addBtn.addEventListener('click', function() {
                const name = prompt('Enter speaker name:');
                if (name && name.trim()) {
                    const speakerId = 'manual_' + Date.now();
                    activeSpeakers.set(speakerId, {
                        name: name.trim(),
                        confidence: 1.0,
                        last_seen: Date.now()
                    });
                    updateActiveSpeakers();
                    
                    // Notify server
                    if (socket && socket.readyState === WebSocket.OPEN) {
                        socket.send(JSON.stringify({
                            'type': 'add_manual_speaker',
                            'speaker_id': speakerId,
                            'speaker_name': name.trim(),
                            'meeting_id': meetingId
                        }));
                    }
                }
            });
        }
        
        if (refreshBtn) {
            refreshBtn.addEventListener('click', function() {
                loadKnownSpeakers();
                
                // Request refresh from server
                if (socket && socket.readyState === WebSocket.OPEN) {
                    socket.send(JSON.stringify({
                        'type': 'refresh_speakers',
                        'meeting_id': meetingId
                    }));
                }
            });
        }
        
        // Request notification permission
        if ('Notification' in window && Notification.permission === 'default') {
            Notification.requestPermission();
        }
    });

    // Remote participation functionality
    function toggleParticipationMode() {
        isRemoteMode = !isRemoteMode;
        const toggle = document.getElementById('participationToggle');
        const recordingControls = document.getElementById('recordingControls');
        const remoteControls = document.getElementById('remoteControls');
        
        if (isRemoteMode) {
            toggle.classList.add('remote');
            recordingControls.style.display = 'none';
            remoteControls.classList.add('active');
            initRemoteMode();
        } else {
            toggle.classList.remove('remote');
            recordingControls.style.display = 'flex';
            remoteControls.classList.remove('active');
            cleanupRemoteMode();
        }
        
        // Update URL without reload
        const url = new URL(window.location);
        if (isRemoteMode) {
            url.searchParams.set('mode', 'remote');
        } else {
            url.searchParams.delete('mode');
        }
        window.history.replaceState({}, '', url);
    }
    
    async function initRemoteMode() {
        try {
            // Get user media for microphone
            remoteAudioStream = await navigator.mediaDevices.getUserMedia({
                audio: {
                    echoCancellation: true,
                    noiseSuppression: true,
                    autoGainControl: true
                }
            });
            
            // Set up remote audio recording
            remoteMediaRecorder = new MediaRecorder(remoteAudioStream);
            remoteMediaRecorder.ondataavailable = handleRemoteAudioData;
            remoteMediaRecorder.start(1000); // Send data every second
            
            // Initialize remote audio listening (placeholder for WebRTC)
            initRemoteAudioListening();
            
            updateConnectionStatus('connected');
            
        } catch (error) {
            console.error('Error initializing remote mode:', error);
            updateConnectionStatus('disconnected');
            alert('Could not access microphone. Please check permissions.');
        }
    }
    
    function cleanupRemoteMode() {
        if (remoteAudioStream) {
            remoteAudioStream.getTracks().forEach(track => track.stop());
            remoteAudioStream = null;
        }
        if (remoteMediaRecorder) {
            remoteMediaRecorder.stop();
            remoteMediaRecorder = null;
        }
        if (remoteAudio) {
            remoteAudio.pause();
            remoteAudio = null;
        }
    }
    
    function handleRemoteAudioData(event) {
        if (event.data.size > 0 && socket && !isMuted) {
            // Send remote audio data to server
            const reader = new FileReader();
            reader.onload = function() {
                socket.send(JSON.stringify({
                    type: 'remote_audio',
                    audio_data: Array.from(new Uint8Array(reader.result)),
                    participant_id: '{{ user.id|default:"anonymous" }}',
                    participant_name: '{{ user.get_full_name|default:user.username|default:"Remote User" }}'
                }));
            };
            reader.readAsArrayBuffer(event.data);
        }
    }
    
    function initRemoteAudioListening() {
        // Placeholder for WebRTC audio streaming
        // This would establish connection to receive room audio
        console.log('Initializing remote audio listening...');
        
        // For now, we'll simulate this with WebSocket messages
        if (socket) {
            socket.send(JSON.stringify({
                type: 'request_audio_stream',
                participant_id: '{{ user.id|default:"anonymous" }}'
            }));
        }
    }
    
    function toggleMicrophone() {
        isMuted = !isMuted;
        const micControl = document.getElementById('micControl');
        const micIcon = document.getElementById('micIcon');
        const micText = document.getElementById('micText');
        
        if (isMuted) {
            micControl.classList.add('muted');
            micIcon.className = 'fas fa-microphone-slash';
            micText.textContent = 'Muted';
        } else {
            micControl.classList.remove('muted');
            micIcon.className = 'fas fa-microphone';
            micText.textContent = 'Microphone';
        }
        
        // Notify other participants
        if (socket) {
            socket.send(JSON.stringify({
                type: 'mic_status',
                participant_id: '{{ user.id|default:"anonymous" }}',
                muted: isMuted
            }));
        }
    }
    
    function updateConnectionStatus(status) {
        const dot = document.getElementById('connectionDot');
        const text = document.getElementById('connectionText');
        
        if (status === 'connected') {
            dot.classList.remove('disconnected');
            text.textContent = 'Connected';
        } else {
            dot.classList.add('disconnected');
            text.textContent = 'Disconnected';
        }
    }
    
    // Event listeners for remote controls
    document.getElementById('participationToggle').addEventListener('click', toggleParticipationMode);
    document.getElementById('micControl').addEventListener('click', toggleMicrophone);
    
    // Volume control
    document.getElementById('volumeSlider').addEventListener('input', function(e) {
        if (remoteAudio) {
            remoteAudio.volume = e.target.value / 100;
        }
    });
    
    // Remote audio message handlers
    function handleRemoteAudioMessage(data) {
        // Process audio from remote participants
        console.log('Remote audio received from:', data.participant_name);
        
        // In a full implementation, this would:
        // 1. Mix remote audio with room audio for recording
        // 2. Add to transcript processing pipeline
        // 3. Play remote audio through room speakers (if enabled)
        
        // For now, we'll create a transcript entry for remote speakers
        if (data.audio_data && data.participant_name) {
            // This would normally go through speech recognition
            // For demo, we'll simulate transcript processing
            addRemoteParticipantTranscript(data.participant_name, '[Speaking remotely...]');
        }
    }
    
    function handleAudioStreamRequest(data) {
        // Handle request from remote participant to receive room audio
        console.log('Audio stream requested by:', data.participant_id);
        
        // In a full implementation, this would:
        // 1. Check if participant has permission
        // 2. Start streaming room audio to this participant
        // 3. Set up WebRTC peer connection
        
        // For now, we'll acknowledge the request
        if (socket && isRecording) {
            socket.send(JSON.stringify({
                type: 'audio_stream_response',
                participant_id: data.participant_id,
                stream_available: true
            }));
        }
    }
    
    function handleMicStatusMessage(data) {
        // Handle microphone status updates from remote participants
        console.log('Mic status update:', data.participant_id, 'muted:', data.muted);
        
        // Update UI to show who's muted (admin view)
        updateRemoteParticipantStatus(data.participant_id, data.muted);
    }
    
    function addRemoteParticipantTranscript(speakerName, text) {
        // Add remote participant speech to transcript
        const transcript = {
            speaker: speakerName + ' (Remote)',
            text: text,
            timestamp: new Date().toISOString(),
            speaker_confidence: 1.0 // Remote speakers are always identified
        };
        updateTranscript(transcript);
    }
    
    function updateRemoteParticipantStatus(participantId, muted) {
        // Update participant status in UI (for admin/host view)
        console.log(`Participant ${participantId} is ${muted ? 'muted' : 'unmuted'}`);
        
        const participantCard = document.querySelector(`[data-participant-id="${participantId}"]`);
        if (participantCard) {
            const statusIcon = participantCard.querySelector('.participant-status-icon');
            const muteBtn = participantCard.querySelector('.participant-mute-btn');
            
            if (muted) {
                statusIcon.className = 'fas fa-microphone-slash participant-status-icon';
                statusIcon.style.color = '#dc3545';
                muteBtn.innerHTML = '<i class="fas fa-volume-up"></i>';
                muteBtn.title = 'Unmute participant';
            } else {
                statusIcon.className = 'fas fa-microphone participant-status-icon';
                statusIcon.style.color = '#64a93f';
                muteBtn.innerHTML = '<i class="fas fa-volume-mute"></i>';
                muteBtn.title = 'Mute participant';
            }
        }
    }
    
    // Manage remote participants
    let remoteParticipants = new Map();
    
    function addRemoteParticipant(participantId, participantName) {
        if (remoteParticipants.has(participantId)) return;
        
        const participant = {
            id: participantId,
            name: participantName,
            muted: false,
            connected: true,
            joinedAt: new Date()
        };
        
        remoteParticipants.set(participantId, participant);
        renderRemoteParticipants();
        
        // Show remote participants section if admin/host
        if (isHost && remoteParticipants.size > 0) {
            document.getElementById('remoteParticipants').style.display = 'block';
        }
    }
    
    function removeRemoteParticipant(participantId) {
        remoteParticipants.delete(participantId);
        renderRemoteParticipants();
        
        // Hide section if no remote participants
        if (remoteParticipants.size === 0) {
            document.getElementById('remoteParticipants').style.display = 'none';
        }
    }
    
    function renderRemoteParticipants() {
        const container = document.getElementById('remoteParticipantsList');
        if (!container) return;
        
        container.innerHTML = '';
        
        remoteParticipants.forEach((participant, id) => {
            const card = document.createElement('div');
            card.className = 'remote-participant-card';
            card.setAttribute('data-participant-id', id);
            
            const initials = participant.name.split(' ').map(n => n[0]).join('').toUpperCase();
            const statusIcon = participant.muted ? 'fa-microphone-slash' : 'fa-microphone';
            const statusColor = participant.muted ? '#dc3545' : '#64a93f';
            
            card.innerHTML = `
                <div class="remote-participant-info">
                    <div class="remote-participant-avatar">${initials}</div>
                    <div>
                        <div class="remote-participant-name">${participant.name}</div>
                        <div class="remote-participant-status">
                            <i class="fas ${statusIcon} participant-status-icon" style="color: ${statusColor}"></i>
                            ${participant.muted ? 'Muted' : 'Speaking'}
                        </div>
                    </div>
                </div>
                ${isHost ? `
                    <div class="remote-participant-controls">
                        <button class="participant-control-btn participant-mute-btn" 
                                onclick="toggleParticipantMute('${id}')" 
                                title="${participant.muted ? 'Unmute participant' : 'Mute participant'}">
                            <i class="fas ${participant.muted ? 'fa-volume-up' : 'fa-volume-mute'}"></i>
                        </button>
                    </div>
                ` : ''}
            `;
            
            container.appendChild(card);
        });
    }
    
    function toggleParticipantMute(participantId) {
        const participant = remoteParticipants.get(participantId);
        if (!participant || !isHost) return;
        
        // Send mute command to participant
        if (socket) {
            socket.send(JSON.stringify({
                type: 'admin_mute_participant',
                participant_id: participantId,
                muted: !participant.muted
            }));
        }
        
        // Update local state (will be confirmed by WebSocket response)
        participant.muted = !participant.muted;
        renderRemoteParticipants();
    }

    // Initialize mode based on URL parameter
    document.addEventListener('DOMContentLoaded', function() {
        if (isRemoteMode) {
            document.getElementById('participationToggle').classList.add('remote');
            document.getElementById('recordingControls').style.display = 'none';
            document.getElementById('remoteControls').classList.add('active');
            initRemoteMode();
        }
    });

    // Handle page unload
    window.addEventListener('beforeunload', function() {
        if (isRecording) {
            stopRecording();
        }
        cleanupRemoteMode();
        if (socket) {
            socket.close();
        }
    });
</script>
{% endblock %}