{% extends 'base.html' %}
{% load static %}

{% block title %}Meeting: {{ meeting.title|default:meeting.meeting_id }}{% endblock %}

{% block extra_head %}
<style>
    .meeting-room {
        max-width: 1200px;
        margin: 0 auto;
        padding: 20px;
    }
    .participants-section {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin: 20px 0;
        padding: 20px;
        background: #f9f9f9;
        border-radius: 8px;
    }
    .host-info {
        display: flex;
        align-items: center;
        gap: 10px;
    }
    .host-badge {
        background: #4CAF50;
        color: white;
        padding: 4px 12px;
        border-radius: 20px;
        font-size: 12px;
        font-weight: bold;
    }
    .recording-phone {
        font-size: 24px;
        margin-right: 10px;
    }
    .participants-count {
        font-size: 14px;
        color: #666;
    }
    .role-indicator {
        padding: 8px 16px;
        border-radius: 20px;
        font-weight: bold;
        margin-left: 10px;
    }
    .role-host {
        background: #4CAF50;
        color: white;
    }
    .role-participant {
        background: #2196F3;
        color: white;
    }
    .controls {
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        background: white;
        border-top: 1px solid #ddd;
        padding: 20px;
        display: flex;
        justify-content: center;
        gap: 20px;
    }
    .btn {
        padding: 12px 24px;
        border: none;
        border-radius: 8px;
        font-size: 16px;
        cursor: pointer;
        transition: all 0.3s;
    }
    .btn-record {
        background: #4CAF50;
        color: white;
    }
    .btn-record:hover {
        background: #45a049;
    }
    .btn-stop {
        background: #f44336;
        color: white;
    }
    .btn-leave {
        background: #9E9E9E;
        color: white;
    }
    .recording-indicator {
        position: fixed;
        top: 20px;
        right: 20px;
        background: #f44336;
        color: white;
        padding: 10px 20px;
        border-radius: 20px;
        display: none;
        align-items: center;
        gap: 10px;
    }
    .recording-indicator.active {
        display: flex;
    }
    .pulse {
        width: 10px;
        height: 10px;
        background: white;
        border-radius: 50%;
        animation: pulse 1.5s infinite;
    }
    @keyframes pulse {
        0% { opacity: 1; }
        50% { opacity: 0.3; }
        100% { opacity: 1; }
    }
    .transcript-container {
        background: #f9f9f9;
        border-radius: 8px;
        padding: 20px;
        margin: 20px 0;
        max-height: 300px;
        overflow-y: auto;
    }
    .transcript-segment {
        margin: 10px 0;
        padding: 10px;
        background: white;
        border-radius: 4px;
        position: relative;
    }
    .speaker-label {
        font-weight: bold;
        color: #333;
        margin-bottom: 5px;
        display: flex;
        align-items: center;
        gap: 10px;
    }
    .unknown-speaker {
        color: #ff6b6b;
    }
    .speaker-edit-btn {
        background: #ffc107;
        color: #212529;
        border: none;
        padding: 2px 8px;
        border-radius: 4px;
        font-size: 12px;
        cursor: pointer;
    }
    .speaker-dropdown {
        background: white;
        border: 1px solid #ddd;
        border-radius: 4px;
        padding: 5px;
        font-size: 12px;
        margin-left: 5px;
    }
    .speaker-management {
        background: #f8f9fa;
        padding: 20px;
        border-radius: 8px;
        margin: 20px 0;
    }
    .active-speakers {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        margin: 15px 0;
    }
    .speaker-tag {
        background: #e9ecef;
        padding: 5px 12px;
        border-radius: 20px;
        font-size: 14px;
        display: flex;
        align-items: center;
        gap: 5px;
    }
    .speaker-tag.active {
        background: #28a745;
        color: white;
    }
    .speaker-tag.unknown {
        background: #ffc107;
        color: #212529;
    }
</style>
{% endblock %}

{% block content %}
<div class="meeting-room">
    <div class="recording-indicator" id="recordingIndicator">
        <div class="pulse"></div>
        <span>Recording</span>
    </div>

    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
        <div>
            <h1>{{ meeting.title|default:"Meeting" }}</h1>
            <p>Meeting ID: <strong>{{ meeting.meeting_id }}</strong></p>
        </div>
        <div id="userRole" class="role-indicator"></div>
    </div>

    <div class="participants-section">
        <div class="host-info">
            <span class="recording-phone">üì±</span>
            <div>
                <div><strong id="hostName">{{ meeting.host.get_full_name|default:meeting.host.username|default:"Host" }}</strong> 
                <span class="host-badge">HOST</span></div>
                <div class="participants-count">Recording Phone</div>
            </div>
        </div>
        <div>
            <span id="participantCount">0</span> participant(s) viewing
        </div>
    </div>

    <div class="speaker-management" id="speakerManagement" style="display: none;">
        <h3>üë• Active Speakers</h3>
        <p style="color: #666; margin-bottom: 15px;">Manage speaker identification during the meeting</p>
        
        <div class="active-speakers" id="activeSpeakers">
            <!-- Speaker tags will be populated dynamically -->
        </div>
        
        <div style="margin-top: 15px;">
            <button id="addSpeakerBtn" class="btn" style="background: #28a745; color: white; padding: 8px 16px;">
                ‚ûï Add Speaker
            </button>
            <button id="refreshSpeakersBtn" class="btn" style="background: #6c757d; color: white; padding: 8px 16px; margin-left: 10px;">
                üîÑ Refresh
            </button>
        </div>
    </div>

    <div class="transcript-container" id="transcriptContainer">
        <h3>Live Transcript</h3>
        <div id="transcriptContent">
            <p style="color: #999;">Transcript will appear here when recording starts...</p>
        </div>
    </div>

    <div class="controls" id="controlsSection">
        <!-- Controls will be added dynamically based on user role -->
    </div>
</div>

<script>
    const meetingId = "{{ meeting.meeting_id }}";
    const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
    const wsUrl = `${wsProtocol}//${window.location.host}/ws/meeting/${meetingId}/`;
    
    let socket = null;
    let mediaRecorder = null;
    let audioChunks = [];
    let isRecording = false;
    let userRole = null; // 'host' or 'participant'
    let isHost = {{ meeting.host.id|default:'null' }} === {{ user.id|default:'null' }};
    let participantCount = 0;
    let activeSpeakers = new Map(); // speaker_id -> {name, confidence, last_seen}
    let knownSpeakers = new Map(); // email -> speaker_profile
    let transcriptSegments = [];

    // Initialize WebSocket connection
    function connectWebSocket() {
        socket = new WebSocket(wsUrl);
        
        socket.onopen = function(e) {
            console.log('WebSocket connected');
            userRole = isHost ? 'host' : 'participant';
            updateUI();
            
            socket.send(JSON.stringify({
                'type': 'join',
                'meeting_id': meetingId,
                'role': userRole,
                'device_type': detectDeviceType()
            }));
        };
        
        socket.onmessage = function(e) {
            const data = JSON.parse(e.data);
            handleWebSocketMessage(data);
        };
        
        socket.onclose = function(e) {
            console.log('WebSocket disconnected');
            setTimeout(connectWebSocket, 3000); // Reconnect after 3 seconds
        };
        
        socket.onerror = function(e) {
            console.error('WebSocket error:', e);
        };
    }

    // Handle incoming WebSocket messages
    function handleWebSocketMessage(data) {
        switch(data.type) {
            case 'participant_joined':
                participantCount++;
                updateParticipantCount();
                break;
            case 'participant_left':
                participantCount = Math.max(0, participantCount - 1);
                updateParticipantCount();
                break;
            case 'recording_started':
                updateRecordingStatus(true);
                break;
            case 'recording_stopped':
                updateRecordingStatus(false);
                break;
            case 'transcript_update':
                updateTranscript(data.transcript);
                break;
            case 'participant_count':
                participantCount = data.count;
                updateParticipantCount();
                break;
            case 'speaker_identified':
                handleSpeakerIdentification(data.speaker);
                break;
            case 'speaker_unknown':
                handleUnknownSpeaker(data.speaker_id, data.transcript);
                break;
        }
    }

    // Update UI based on user role
    function updateUI() {
        const roleElement = document.getElementById('userRole');
        const controlsSection = document.getElementById('controlsSection');
        
        if (userRole === 'host') {
            roleElement.textContent = 'HOST';
            roleElement.className = 'role-indicator role-host';
            
            // Add host controls
            controlsSection.innerHTML = `
                <button id="startRecordingBtn" class="btn btn-record">
                    üì± Start Recording
                </button>
                <button id="stopRecordingBtn" class="btn btn-stop" style="display: none;">
                    ‚èπÔ∏è Stop Recording
                </button>
                <button id="leaveMeetingBtn" class="btn btn-leave">
                    üö™ End Meeting
                </button>
            `;
            
            // Add event listeners for host controls
            document.getElementById('startRecordingBtn').addEventListener('click', startRecording);
            document.getElementById('stopRecordingBtn').addEventListener('click', stopRecording);
            document.getElementById('leaveMeetingBtn').addEventListener('click', endMeeting);
            
        } else {
            roleElement.textContent = 'PARTICIPANT';
            roleElement.className = 'role-indicator role-participant';
            
            // Add participant controls (view-only)
            controlsSection.innerHTML = `
                <div style="text-align: center; padding: 20px;">
                    <p style="color: #666; margin-bottom: 10px;">
                        üëÅÔ∏è You're viewing this meeting
                    </p>
                    <p style="font-size: 14px; color: #999;">
                        Only the host can control recording
                    </p>
                    <button id="leaveMeetingBtn" class="btn btn-leave">
                        üö™ Leave Meeting
                    </button>
                </div>
            `;
            
            document.getElementById('leaveMeetingBtn').addEventListener('click', leaveMeeting);
        }
    }

    // Update participant count display
    function updateParticipantCount() {
        document.getElementById('participantCount').textContent = participantCount;
    }

    // Update recording status
    function updateRecordingStatus(recordingActive) {
        const indicator = document.getElementById('recordingIndicator');
        if (recordingActive) {
            indicator.classList.add('active');
            if (userRole === 'host') {
                document.getElementById('startRecordingBtn').style.display = 'none';
                document.getElementById('stopRecordingBtn').style.display = 'inline-block';
            }
        } else {
            indicator.classList.remove('active');
            if (userRole === 'host') {
                document.getElementById('startRecordingBtn').style.display = 'inline-block';
                document.getElementById('stopRecordingBtn').style.display = 'none';
            }
        }
        isRecording = recordingActive;
    }

    // Update transcript
    function updateTranscript(transcript) {
        const content = document.getElementById('transcriptContent');
        const segment = document.createElement('div');
        segment.className = 'transcript-segment';
        segment.setAttribute('data-segment-id', transcript.segment_id || Date.now());
        
        const speakerClass = transcript.speaker_confidence < 0.5 ? 'unknown-speaker' : '';
        const editButton = userRole === 'host' && transcript.speaker_confidence < 0.5 ? 
            '<button class="speaker-edit-btn" onclick="editSpeaker(this)">Edit</button>' : '';
        
        segment.innerHTML = `
            <div class="speaker-label ${speakerClass}">
                ${transcript.speaker || 'Unknown Speaker'}
                ${editButton}
            </div>
            <div>${transcript.text}</div>
        `;
        
        content.appendChild(segment);
        transcriptSegments.push(transcript);
        
        // Auto-scroll to bottom
        const container = document.getElementById('transcriptContainer');
        container.scrollTop = container.scrollHeight;
    }
    
    // Handle speaker identification
    function handleSpeakerIdentification(speaker) {
        activeSpeakers.set(speaker.id, {
            name: speaker.name,
            confidence: speaker.confidence,
            last_seen: Date.now()
        });
        updateActiveSpeakers();
    }
    
    // Handle unknown speaker
    function handleUnknownSpeaker(speakerId, transcript) {
        if (!activeSpeakers.has(speakerId)) {
            activeSpeakers.set(speakerId, {
                name: `Unknown Speaker ${activeSpeakers.size + 1}`,
                confidence: 0.0,
                last_seen: Date.now()
            });
            updateActiveSpeakers();
        }
    }
    
    // Update active speakers display
    function updateActiveSpeakers() {
        const container = document.getElementById('activeSpeakers');
        container.innerHTML = '';
        
        activeSpeakers.forEach((speaker, speakerId) => {
            const tag = document.createElement('div');
            tag.className = `speaker-tag ${speaker.confidence > 0.7 ? 'active' : 'unknown'}`;
            tag.innerHTML = `
                <span>${speaker.name}</span>
                <small>(${Math.round(speaker.confidence * 100)}%)</small>
                ${userRole === 'host' ? '<button onclick="editSpeakerName(\'' + speakerId + '\')">‚úèÔ∏è</button>' : ''}
            `;
            container.appendChild(tag);
        });
        
        // Show speaker management section if there are active speakers
        if (activeSpeakers.size > 0 && userRole === 'host') {
            document.getElementById('speakerManagement').style.display = 'block';
        }
    }
    
    // Edit speaker name inline
    function editSpeaker(button) {
        if (userRole !== 'host') return;
        
        const segment = button.closest('.transcript-segment');
        const speakerLabel = segment.querySelector('.speaker-label');
        const currentName = speakerLabel.textContent.replace('Edit', '').trim();
        
        // Create dropdown with known speakers + option to add new
        const dropdown = document.createElement('select');
        dropdown.className = 'speaker-dropdown';
        
        // Add known speakers
        knownSpeakers.forEach((profile, email) => {
            const option = document.createElement('option');
            option.value = profile.name;
            option.textContent = profile.name;
            dropdown.appendChild(option);
        });
        
        // Add current active speakers
        activeSpeakers.forEach((speaker, id) => {
            const option = document.createElement('option');
            option.value = speaker.name;
            option.textContent = speaker.name;
            dropdown.appendChild(option);
        });
        
        // Add "New Speaker" option
        const newOption = document.createElement('option');
        newOption.value = 'NEW';
        newOption.textContent = '+ New Speaker...';
        dropdown.appendChild(newOption);
        
        dropdown.value = currentName;
        dropdown.addEventListener('change', function() {
            if (this.value === 'NEW') {
                const newName = prompt('Enter speaker name:');
                if (newName) {
                    updateSegmentSpeaker(segment, newName);
                }
            } else {
                updateSegmentSpeaker(segment, this.value);
            }
            this.remove();
        });
        
        button.replaceWith(dropdown);
        dropdown.focus();
    }
    
    // Edit speaker name from active speakers
    function editSpeakerName(speakerId) {
        if (userRole !== 'host') return;
        
        const speaker = activeSpeakers.get(speakerId);
        const newName = prompt('Enter new name for speaker:', speaker.name);
        
        if (newName && newName.trim()) {
            speaker.name = newName.trim();
            activeSpeakers.set(speakerId, speaker);
            updateActiveSpeakers();
            
            // Update all transcript segments for this speaker
            updateTranscriptSpeakerName(speaker.name, newName.trim());
            
            // Notify server
            if (socket && socket.readyState === WebSocket.OPEN) {
                socket.send(JSON.stringify({
                    'type': 'update_speaker_name',
                    'speaker_id': speakerId,
                    'new_name': newName.trim(),
                    'meeting_id': meetingId
                }));
            }
        }
    }
    
    // Update segment speaker
    function updateSegmentSpeaker(segment, newName) {
        const speakerLabel = segment.querySelector('.speaker-label');
        speakerLabel.innerHTML = `${newName} <button class="speaker-edit-btn" onclick="editSpeaker(this)">Edit</button>`;
        speakerLabel.classList.remove('unknown-speaker');
        
        // Notify server about the change
        const segmentId = segment.getAttribute('data-segment-id');
        if (socket && socket.readyState === WebSocket.OPEN) {
            socket.send(JSON.stringify({
                'type': 'update_segment_speaker',
                'segment_id': segmentId,
                'speaker_name': newName,
                'meeting_id': meetingId
            }));
        }
    }
    
    // Update transcript speaker name globally
    function updateTranscriptSpeakerName(oldName, newName) {
        const segments = document.querySelectorAll('.transcript-segment');
        segments.forEach(segment => {
            const speakerLabel = segment.querySelector('.speaker-label');
            if (speakerLabel.textContent.includes(oldName)) {
                speakerLabel.innerHTML = speakerLabel.innerHTML.replace(oldName, newName);
            }
        });
    }
    
    // Load known speakers
    async function loadKnownSpeakers() {
        try {
            const response = await fetch(`/api/meeting/${meetingId}/speakers/`);
            if (response.ok) {
                const data = await response.json();
                knownSpeakers.clear();
                data.known_speakers.forEach(speaker => {
                    knownSpeakers.set(speaker.email, {
                        name: speaker.name,
                        email: speaker.email,
                        job_title: speaker.job_title
                    });
                });
            }
        } catch (error) {
            console.error('Error loading known speakers:', error);
        }
    }

    // Update meeting status
    function updateMeetingStatus(status) {
        document.getElementById('meetingStatus').textContent = status;
    }

    // Detect device type
    function detectDeviceType() {
        const userAgent = navigator.userAgent.toLowerCase();
        if (/iphone|ipod|android.*mobile|windows phone/i.test(userAgent)) {
            return 'mobile';
        } else if (/ipad|android(?!.*mobile)/i.test(userAgent)) {
            return 'tablet';
        }
        return 'desktop';
    }

    // Start recording (host only)
    async function startRecording() {
        if (userRole !== 'host') {
            alert('Only the host can control recording.');
            return;
        }
        
        try {
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            mediaRecorder = new MediaRecorder(stream);
            
            mediaRecorder.ondataavailable = function(event) {
                if (event.data.size > 0) {
                    audioChunks.push(event.data);
                }
            };
            
            mediaRecorder.onstop = function() {
                const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                uploadAudio(audioBlob);
                audioChunks = [];
            };
            
            mediaRecorder.start();
            updateRecordingStatus(true);
            
            // Notify all participants via WebSocket
            if (socket && socket.readyState === WebSocket.OPEN) {
                socket.send(JSON.stringify({
                    'type': 'recording_started',
                    'meeting_id': meetingId,
                    'host_recording': true
                }));
            }
        } catch (error) {
            console.error('Error starting recording:', error);
            alert('Could not access microphone. Please check permissions and ensure you\'re using HTTPS.');
        }
    }

    // Stop recording (host only)
    function stopRecording() {
        if (userRole !== 'host') {
            return;
        }
        
        if (mediaRecorder && isRecording) {
            mediaRecorder.stop();
            updateRecordingStatus(false);
            
            // Notify all participants via WebSocket
            if (socket && socket.readyState === WebSocket.OPEN) {
                socket.send(JSON.stringify({
                    'type': 'recording_stopped',
                    'meeting_id': meetingId
                }));
            }
            
            // Stop all tracks
            mediaRecorder.stream.getTracks().forEach(track => track.stop());
        }
    }

    // Upload audio to server
    async function uploadAudio(audioBlob) {
        const formData = new FormData();
        formData.append('audio', audioBlob, 'recording.webm');
        formData.append('meeting_id', meetingId);
        
        try {
            const response = await fetch('/api/upload-audio/', {
                method: 'POST',
                body: formData,
                headers: {
                    'X-CSRFToken': getCookie('csrftoken')
                }
            });
            
            if (response.ok) {
                console.log('Audio uploaded successfully');
            } else {
                console.error('Failed to upload audio');
            }
        } catch (error) {
            console.error('Error uploading audio:', error);
        }
    }

    // Get CSRF token
    function getCookie(name) {
        let cookieValue = null;
        if (document.cookie && document.cookie !== '') {
            const cookies = document.cookie.split(';');
            for (let i = 0; i < cookies.length; i++) {
                const cookie = cookies[i].trim();
                if (cookie.substring(0, name.length + 1) === (name + '=')) {
                    cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                    break;
                }
            }
        }
        return cookieValue;
    }

    // End meeting (host only)
    function endMeeting() {
        if (userRole !== 'host') {
            return;
        }
        
        if (confirm('Are you sure you want to end the meeting for everyone?')) {
            if (isRecording) {
                stopRecording();
            }
            
            if (socket) {
                socket.send(JSON.stringify({
                    'type': 'meeting_ended',
                    'meeting_id': meetingId
                }));
                socket.close();
            }
            
            window.location.href = '/';
        }
    }

    // Leave meeting (participant)
    function leaveMeeting() {
        if (socket) {
            socket.send(JSON.stringify({
                'type': 'leave',
                'meeting_id': meetingId
            }));
            socket.close();
        }
        
        window.location.href = '/';
    }

    // Event listeners are now added dynamically in updateUI() function

    // Initialize on page load
    document.addEventListener('DOMContentLoaded', function() {
        connectWebSocket();
        loadKnownSpeakers();
        
        // Speaker management event listeners
        document.getElementById('addSpeakerBtn').addEventListener('click', function() {
            const name = prompt('Enter speaker name:');
            if (name && name.trim()) {
                const speakerId = 'manual_' + Date.now();
                activeSpeakers.set(speakerId, {
                    name: name.trim(),
                    confidence: 1.0,
                    last_seen: Date.now()
                });
                updateActiveSpeakers();
                
                // Notify server
                if (socket && socket.readyState === WebSocket.OPEN) {
                    socket.send(JSON.stringify({
                        'type': 'add_manual_speaker',
                        'speaker_id': speakerId,
                        'speaker_name': name.trim(),
                        'meeting_id': meetingId
                    }));
                }
            }
        });
        
        document.getElementById('refreshSpeakersBtn').addEventListener('click', function() {
            loadKnownSpeakers();
            
            // Refresh from server
            if (socket && socket.readyState === WebSocket.OPEN) {
                socket.send(JSON.stringify({
                    'type': 'refresh_speakers',
                    'meeting_id': meetingId
                }));
            }
        });
        
        // Request notification permission for meeting alerts
        if ('Notification' in window && Notification.permission === 'default') {
            Notification.requestPermission();
        }
    });

    // Handle page unload
    window.addEventListener('beforeunload', function() {
        if (isRecording) {
            stopRecording();
        }
        if (socket) {
            socket.close();
        }
    });
</script>
{% endblock %}